


[{"content":"","date":"17 August 2025","externalUrl":null,"permalink":"/cpp/","section":"Cpps","summary":"","title":"Cpps","type":"cpp"},{"content":"c++学习笔记\n函数指针 # 声明和初始化函数指针 # // 声明一个函数指针 pf 可以指向 返回值为bool 且 形参为两个 const string \u0026amp; 的函数 bool (*pf) (const string \u0026amp;, const string \u0026amp;); // 声明一个上述形式的函数 bool comparator(const string \u0026amp; a, const string \u0026amp; b); // 两种等效方式 可以正确赋值函数指针 函数指针会自动解引用 pf = comparator; pf = *comparator; 函数形参声明函数指针\n#include \u0026lt;signal.h\u0026gt; void (*signal (int signo, void (*func) (int))); 上面的signal函数有两个形参，一个是int类型的signal，另一个是无返回值，有一个int类型形参「void (\\*p) (int)」的函数指针，并且signal函数的返回类型是一个「void (*ptr) (int)」函数指针。\n信号处理 # 注册信号 # 使用signal函数注册信号\n#include \u0026lt;signal.h\u0026gt; void (*signal (int signo, void (*func) (int))); // eg1:注册为SIGINT信号注册处理函数keycontrol void keycontrol(); signal(SIGINT, keycontrol); // 注册上述信号之后 按下control+c会执行keycontrol函数 以上就是注册信号的过程。之后发生对应注册信号后，操作系统将调用注册好的函数。\n下面介绍alarm函数\n#include \u0026lt;unistd.h\u0026gt; unsigned int alarm(unsigned int seconds); 如果调用该函数的同时向它传递一个正整型参数，相应时间后（以秒为单位）将产生SIGALRM信号。若向该函数传递0，则之前对SIGALRM信号的预约将取消。如果通过该函数预约信号后未指定该信号对应的处理函数，则（通过调用signal函数）终止进程，不做任何处理。希望引起注意。\nsignal函数在UNIX系列的不同操作系统中可能存在区别，但sigaction函数完全相同。\n#include \u0026lt;signal.h\u0026gt; // 成功返回0，失败返回-1 int\tsigaction(int signo, const struct sigaction * act,struct sigaction * oldact); // sigaction结构体定义如下 struct sigaction { union __sgaction_u __sigaction_u; /* signal handler */ sigset_t sa_mask; /* signal mask to apply */ int sa_flags; /* see signal options below */ }; 进程 # 进程变为僵尸进程的过程及预防措施 # 变为僵尸进程的过程：\n子进程先于父进程终止 子进程退出后，内核会释放其大部分资源（内存、打开文件等），但仍在进程表中保留一个条目（task_struct），其中包含了子进程的退出状态等信息，等待父进程读取（通过wait()或waitpid()系统调用）。这个状态下的子进程就是僵尸进程（Zombie Process）。 如果父进程一直没有读取子进程的退出状态，这个僵尸进程的进程表条目就会一直存在。 这些僵尸进程会占用进程号（PID），系统可用的PID数量是有限的，同时僵尸进程占用内核进程表中的少量内存。\n预防措施：\n父进程调用wait()或waitpid()：主动回收已终止的子进程。 阻塞等待：wait(NULL)会阻塞直到一个子进程终止。 非阻塞等待：waitpid(-1, \u0026amp;status, WNOHANG)立即返回，检查是否有子进程终止，没有也不阻塞。 忽略SIGCHLD信号：通过signal(SIGCHLD, SIG_IGN)或sigaction设置。告诉内核子进程终止后直接清理，无需等待父进程读取状态。注意：虽然传统和现代Linux系统支持此方法自动回收，但POSIX.1标准未定义此行为，最好使用wait系列函数。 使用信号处理函数：为SIGCHLD信号安装处理函数，在函数内部调用waitpid来回收子进程。这是最常用和可靠的方法。 父进程先终止：让父进程先于子进程结束，这样子进程会变成孤儿进程，被init进程（PID 1）收养。init进程会定期调用wait()清理其所有的子进程（僵尸进程）。 进程间通信 # 什么是进程间通信？分别从概念上和内存的角度进行说明。\n概念上： 进程间通信（Inter-Process Communication, IPC）是指两个或多个进程之间进行数据交换、信息传递或同步操作的机制。由于进程是操作系统中最基本的独立执行单元，每个进程都拥有自己独立的地址空间和资源，因此需要专门的IPC机制来打破这种隔离，实现协作。\n从内存角度： 每个进程都有自己独立的虚拟内存空间，由一个页表映射到物理内存。这意味着：\n进程A无法直接访问进程B的内存数据（如全局变量）。 如果尝试直接访问另一个进程的地址，会导致段错误（Segmentation Fault）。 因此，IPC必须通过操作系统内核作为中介。内核拥有所有进程内存的映射权限，可以提供共享的内存区域或在不同的进程地址空间之间传递数据。常见的IPC方式如管道、消息队列、共享内存等，本质上都是通过内核分配一块双方进程都能访问的区域（可能是内核缓冲区或共享内存段）来实现数据交换。\n下面演示使用fork函数传递pipe\n// pipe1.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define BUF_SIZE 30 int main(int argc, char *argv[]) { int fd[2]; pipe(fd); char buf[BUF_SIZE] = \u0026#34;Hello World!!!\u0026#34;; pid_t pid; pid = fork(); if (pid == 0) { write(fd[1], buf, sizeof(buf)); } else { read(fd[0], buf, sizeof(buf)); puts(buf); } return 0; } 下面尝试通过1个管道进行2个进程间双向数据交换的示例，其通信方式如下图所示：\n// pipe2.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define BUF_SIZE 30 /** * @brief 两个进程使用一个管道实现双向通信 */ int main(int argc, char *argv[]) { int fd[2]; pipe(fd); char message1[BUF_SIZE] = \u0026#34;Hello Dad!!!\u0026#34;; char message2[BUF_SIZE] = \u0026#34;Hello Son!!!\u0026#34;; char buf[BUF_SIZE]; pid_t pid; pid = fork(); if (pid == 0) { write(fd[1], message1, sizeof(message1)); sleep(2); read(fd[0], buf, sizeof(buf)); printf(\u0026#34;Child read: %s\\n\u0026#34;, buf); } else { read(fd[0], buf, sizeof(buf)); printf(\u0026#34;Parent read: %s\\n\u0026#34;, buf); write(fd[1], message2, sizeof(message2)); sleep(3); } return 0; } 该程序运行结果如下： 但如果将20行的代码sleep(2)注释掉，然后重新编译运行，运行结果是这样的： 可以观察到程序发生了错误，控制台观察不到第二个输出，那么为什么会发生这样的错误呢？\n“向管道传递数据时，先读的进程会把数据取走。”\n简言之，数据进入管道后成为无主数据。也就是通过read函数先读取数据的进程将得到数据，即使该进程将数据传到了管道。因此，注释第20行将产生问题。在第21行，子进程将读回自已在第19行向管道发送的数据。结果，父进程调用read函数后将无限期等待数据进入管道。\n从上述示例中可以看到，只用1个管道进行双向通信并非易事。为了实现这一点，程序需要预测并控制运行流程，这在每种系统都不同，可以视为不可能完成的任务。\n既然如此，该如何进行双向通信呢？\n创建2个管道。\n非常简单，1个管道无法完成双向通信任务，因此需要创建2个管道，各自负责不同的数据流动即可。其过程如下图所示。\n这样就可以就可以避免程序流程的预测和控制，下面采用上述模型对pipe2.c进行改造。\n// pipe3.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define BUF_SIZE 30 /** * @brief 使用两个管道实现双向通信 * @param argc 命令行参数数量 * @param argv 命令行参数数组 * @return int 0 正常退出 1 异常退出 */ int main(int argc, char *argv[]) { int fds1[2], fds2[2]; char message1[BUF_SIZE] = \u0026#34;Who are you?\u0026#34;; char message2[BUF_SIZE] = \u0026#34;I am your dad, clean.\u0026#34;; char buf[BUF_SIZE]; pid_t pid; pipe(fds1); pipe(fds2); pid = fork(); if (pid == 0) { write(fds1[1], message1, sizeof(message1)); read(fds2[0], buf, BUF_SIZE); printf(\u0026#34;Child process receive: %s\\n\u0026#34;, buf); } else { read(fds1[0], buf, BUF_SIZE); printf(\u0026#34;Parent process receive: %s\\n\u0026#34;, buf); write(fds2[1], message2, sizeof(message2)); sleep(3); } return 0; } ","date":"17 August 2025","externalUrl":null,"permalink":"/cpp/fundamental/","section":"Cpps","summary":"","title":"语言基础","type":"cpp"},{"content":" 前置知识 # C语言基础 操作系统知识（多线程、系统调用） 计算机网络（传输层、网络层） 以\u0026quot;_t\u0026quot;为后缀的数据类型 P12 # 以\u0026quot;_t\u0026quot;为后缀的数据类型是系统定义的类型，称为元数据类型。\n注意下面write系统调用的函数签名\n#include \u0026lt;unistd.h\u0026gt; // 成功时返回写入的字节数 失败返回-1 ssize_t write(int fd, const *void buf, size_t nbytes); 操作系统定义了这种元数据类型，实际上是为一些基本数据类型起了别名。\n在不同位的操作系统中不同的数据类型的底层位数可能不同，如我们常接触的的int是32位的，某些64位的操作系统中，可能会将int扩展到8字节，我们教操作系统定义系统类型，使用定义好的元数据类型可以方便程序移植，即在不同操作系统中不必逐个调整程序中的变量类型。\n应用场景：元数据类型在文件操作、内存分配、跨平台兼容场景有着应用。\n// 1. 文件操作 #include \u0026lt;unistd.h\u0026gt; ssize_t read(int fd, void *buf, size_t count); // 返回值用ssize_t：可能返回-1表示错误 // count用size_t：大小不能为负数 // 2. 内存分配 void *malloc(size_t size); // 分配内存大小用size_t // 3. 跨平台兼容 // 不好的写法 unsigned int packet_size; // 在16位系统可能溢出！ // 好的写法 size_t packet_size; // 自动适应系统位数 书上知识补给站描述如下\n第一章习题 P24 # (1)套接字在网络编程中的作用是什么？ # 作用：\n套接字将复杂的网络协议（三次握手，数据包重组）封装成简单的API，使开发者无需关注底层细节。 套接字允许不同主机（或同一主机）上的进程通过IP地址和端口号相互通信，支持TCP/IP、UDP等协议。 (2) bind()、listen()和accept()的作用与区别 # 函数 作用 调用时机 bind() 标识通信端点：通过IP地址+端口号确定数据应发送到哪个主机的哪个进程。 listen()之前 listen() 将套接字设为被动模式，声明愿意接受连接，并设置连接请求队列的最大长度。 bind()之后accept()之前 accept() 从连接队列中取出一个已建立的连接，返回一个新的套接字用于与该客户端通信。原套接字继续监听。 在listen()之后循环调用 (3) Linux vs Windows的套接字I/O差异 # Linux中，对套接字数据进行I/O时可以直接使用文件I/O相关函数；而在Windows中则不\u2029可以。原因为何？\nLinux允许文件I/O函数操作套接字：\n一切皆文件：Linux将套接字、管道、设备等均抽象为文件描述符，统一用read()/write()等文件I/O函数操作。 Windows不允许：\n分离设计：Windows严格区分文件操作（ReadFile()）和网络操作（recv()/send()），套接字用SOCKET类型而非文件句柄。 (6)底层文件IO函数与ANSI标准定义的文件I/O函数之间有何区别？ # 特性 底层IO(系统调用) ANSI标准IO 缓冲 无缓冲/内核缓冲 用户态缓冲 函数 open(), read(), write() fopen(), fread(), fprintf() 一致性 不同OS跨平台差异大 标准库，跨平台一致 (7）利用底层文件I/O和ANSI标准I/O编写文件复制程序。可任意指定复制程序的使用方法。 # 底层IO版\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int main() { int src_fd = open(\u0026#34;src.txt\u0026#34;, O_RDONLY); int dst_fd = open(\u0026#34;dst.txt\u0026#34;, O_WRONLY | O_CREAT, 0644); char buf[1024]; ssize_t n; while ((n = read(src_fd, buf, sizeof(buf))) \u0026gt; 0) { write(dst_fd, buf, n); } close(src_fd); close(dst_fd); return 0; } ANSI标准IO版\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE *src = fopen(\u0026#34;src.txt\u0026#34;, \u0026#34;r\u0026#34;); FILE *dst = fopen(\u0026#34;dst.txt\u0026#34;, \u0026#34;w\u0026#34;); char buf[1024]; while (fgets(buf, sizeof(buf), src) != NULL) { fputs(buf, dst); } fclose(src); fclose(dst); return 0; } 面向连接的套接字 P28 # 面向连接的套接字（SOCK_STREAM）具有如下特点：\n传输过程中数据不会丢失 按序传输数据 传输的数据不存在数据边界（Boundary） TIPS：\n数据边界是通信过程中消息与消息之间的分割线，面向连接的套接字中，消息以数据流传输，不存在数据边界。 收发数据的套接字有缓冲区（buffer），是一个字符数组。write()和read()就是对于缓冲区进行操作。因此write()和read()的使用次数没什么意义。 当收缓冲区满时，套接字无法继续接受数据，此时TCP会进行流量控制，发送端停止发数据，因此**面向连接的套接字不会发生数据丢失**。 表示IPV4地址的结构体 P49 # c++中用sockaddr_in结构体表示IPV4地址结构，结构体具体的定义如下：\n// sockaddr_in struct sockaddr_in { __uint8_t sin_len; sa_family_t sin_family; // 地址族（Address Family） in_port_t sin_port; // 端口号（16位） struct in_addr sin_addr; // IP地址（32位） char sin_zero[8]; // 为使 sockaddr_in 与 sockaddr 大小一致而插入 无特殊意义 填充为0 }; struct in_addr { in_addr_t s_addr; // 源码中定义了 typedef __uint32_t in_addr_t; 即in_addr_t 是 unsigned int (32bit) 用于表示IP地址 }; // sockaddr struct sockaddr { __uint8_t sa_len; /* total length */ sa_family_t sa_family; /* [XSI] address family */ char sa_data[14]; /* [XSI] addr value */ }; I/O复用服务器端模型的理解 # ","date":"2 August 2025","externalUrl":null,"permalink":"/cpp/tcpip%E7%BC%96%E7%A8%8B/","section":"Cpps","summary":"","title":"Tcpip编程","type":"cpp"},{"content":"","date":"21 June 2025","externalUrl":null,"permalink":"/java/","section":"Javas","summary":"","title":"Javas","type":"java"},{"content":" 面向对象高级 # final关键字 # final是最终的意思，final关键字可以修饰类、方法、变量。\nfinal修饰的类称作最终类，特点是不能被继承。 final修饰的方法称为最终方法，特点是不能被重写。 final修饰的变量只能赋值一次。 使用final关键字的场景：\n修饰局部变量：方法内部和方法传入的参数均可用final修饰防止被修改。 修饰静态成员变量：称被修饰的变量为常量。 修饰实例成员变量，一般没意义。 final注意事项：\nfinal修饰基本类型变量，其内容不可改变。 final修饰引用类型变量（如数组），其地址不可改变，而数值可以改变。 常量 # 前面提到了常量，常量就是使用static final关键字修饰的成员变量，常用于记录系统的配置信息。\n使用常量的优势\n使用常量可以提高代码的可读性和可维护性。 😘类似于C的宏定义，在编译过程中，使用常量的地方全部会替换为其字面量，因此使用常量和直接使用其字面量的性能是一样的。 public class Constant{ // 常量命名规范: 全部使用大写字母 单词之间使用\u0026#34;_\u0026#34;隔开 public static final String ZJUT_SCHOOL_CODE = \u0026#34;10337\u0026#34;; public static final String ZJUT_MAIL_CODE = \u0026#34;310014\u0026#34;; public static final String WEBSITE = \u0026#34;http://www.yz.zjut.edu.cn\u0026#34; } 单例类（软件设计模式） SingleInstance Class # 作用：确保某个类只能创建出对象\n饿汉式单例 # 特点：拿对象的时候，对象早就创建好了。\n写法：\n类的构造器私有。 定义一个类变量记住类的一个对象。 定义一个类方法，返回对象。 public class A{ // 1.私有构造器 private A(){ } // 2.定义类变量记住类的一个对象 // public static final A a = new A(); private static A a = new A(); // 3.定义方法返回唯一对象 // 屏蔽除get外的操作 private static A getObject(){ return a; } } 懒汉式单例 # 特点：拿对象时才开始创建对象\n写法：\n私有构造器 定义类变量存储对象 定义方法返回唯一对象 public class B{ // 1.私有构造器 private B(){ } // 2.定义类变量存储对象 private static B b; // 3.定义方法返回唯一对象 private static B getObject(){ if (b == null){ b = new B(); } return b; } } 枚举类 # 认识枚举类\n枚举类的写法：\n// 修饰符 enum 枚举类名{ // 名称1, 名称2,...; // 其他成员... // } // A.java public enum A{ X, Y, Z; ... } 将A.java编译后进行反编译\n(base) clean@fxg Downloads % touch A.java (base) clean@fxg Downloads % vim A.java (base) clean@fxg Downloads % javac A.java (base) clean@fxg Downloads % javap A.class 得到代码如下：\npublic final class A extends java.lang.Enum\u0026lt;A\u0026gt; { public static final A X; public static final A Y; public static final A Z; public static A[] values(); public static A valueOf(java.lang.String); static {}; } 观察到枚举类的一些特点：\n枚举类被final修饰，即枚举类是最终类，不能被继承。 枚举类都继承了java.lang.Enum类 😳枚举类中第一行只能罗列一些名称（如上面A.java例子中的XYZ），这些名称都是常量，并且每个常量会记住枚举类的一个对象。 枚举类的构造器是私有的，因此枚举类不能对外创建对象。 此外，编译器为枚举类新增了几个方法：\npublic static void main(String[] args){ A a1 = A.X; System.out.println(a1); // out: X System.out.println(a1.name()); // out: X System.out.println(a1.ordinal()); // 0 (索引) } 枚举类的常见应用场景\n枚举类适合做信息分类和标志\n抽象类 # abstract 关键字 可以修饰类和方法，被修饰的分别称为抽象类和抽象方法，抽象方法不允许有方法体。\n抽象类的特点：\n抽象类中不一定有抽象方法，有抽象方法必须是抽象类。 类有的成员：成员变量、方法、构造器、抽象类都可以有。 😊抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现。 一个类继承抽象类，必须重写完继承的全部抽象方法，否则这个类也必须定义成抽象类。 抽象类的好处：更好支持多态。\n😜模版方法软件设计模式\n提供一个方法作为完成某类功能的模版，模版方法封装了每个实现步骤，但允许子类提供特定步骤的实现。\n模版方法设计模式可以提高代码复用、简化子类设计。\ntips：\n模版方法使用final修饰，防止被重写。 一旦子类重写模版方法，模版方法失效。 接口（Interface） # //JDK 8以前 接口中只能定义常量和抽象方法： public interface A{ // 接口中定义常量可以省略 public static final String SCHOOL_NAME = \u0026#34;浙江工业大学\u0026#34;; // 接口中定义抽象方法可以省略 public abstract void run(); } // JDK 8开始，接口新增了三种形式的方法： public interface B{ // 1. 默认方法(普通实例方法)，必须用default修饰 // 默认使用public修饰 // 调用方法: 使用接口的实现类的对象调用 default void go { System.out.println(\u0026#34;function go running~~~\u0026#34;); run(); } // 2. 私有方法 // 私有的实例方法 // 调用方法: 使用接口中的其他实例方法调用 private void run { System.out.println(\u0026#34;function run is running~~~\u0026#34;); } // 3. 静态方法(类方法) 使用static修饰 // 默认使用 public 修饰 // 调用方法: 静态方法只能用接口名调用 static void fly { System.out.println(\u0026#34;function fly is running~~~\u0026#34;); } } 😴实现类实现多个结构，必须重写全部接口的全部抽象方法，否则这个类必须定义为抽象类。\n接口的好处\n弥补了类单继承的不足，一个类可以实现多个接口，使类角色更多，功能更强 让程序可以面向接口编程，这样程序员可以灵活方便的切换各种业务实现（更利于程序的解耦合） 接口注意事项：\n接口与接口可以多继承，一个接口可以继承多个接口 多个接口存在方法签名冲突时，不支持多继承和多实现 一个类继承父类的同时实现了接口，如果父类中和接口中有同名的方法，实现类会优先用父类的 一个类实现了多个接口，如果存在同名的默认方法，可以不冲突，这个类重写该方法即可 抽象类、接口的对比 # 相同点：\n都是抽象形式，都可以有抽象方法，都不能创建对象 都是派生子类形式：抽象类时被子类继承使用，接口是被实现类实现 一个类继承抽象类，或者实现接口，都必须重写完他们的抽象方法，否则该类必须为抽象类 都能支持多态，实现解耦合 不同点：\n抽象类中可以定义类的全部普通成员，接口是能定义常量、抽象方法（JDK 8 前） 抽象类只能被单继承，接口能被类多实现 一个类继承抽象类就不能再继承其他类，一个类实现了接口还可以继承其他类或实现其他接口 抽象类体现模版思想，更利于做父类，实现代码的复用性 最佳实践 接口适合做功能的解耦合，解耦合性更强更灵活 最佳实践 代码块 # // 代码块分为下面两种: // 1. 静态代码块 // 格式: static{} // 特点: 类加载时自动执行 由于类只加载一次 所以静态代码块也只会执行一次 // 作用: 完成类的初始化 如对静态变量的初始化赋值 // 2. 实例代码块 // 格式: {} // 特点: 每次创建对象时 执行实例代码块 并在构造器前执行 // 作用: 和构造器一样都是用来完成对象初始化的 如对实例变量进行初始化 public class CodeDemo{ { System.out.println(\u0026#34;====实例代码块====\u0026#34;); } static { System.out.println(\u0026#34;====静态代码块====\u0026#34;); } public static void main(String[] args){ System.out.println(\u0026#34;====main 方法====\u0026#34;); } } 内部类（掌握语法） # 定义：如果一个类定义在另一个类的内部，这个类就是内部类。\n成员内部类 # // 定义 public class Outer { // 没有 static 说明内部类属于对象 public class Inner { public void show(){ System.out.println(\u0026#34;show\u0026#34;); } }\t} // 实例化并调用 public class Main{ public static void main(String[] args){ Outer.Inner oi = new Outer().new Inner(); oi.show(); } } // 成员内部类访问外部类成员的特点（拓展） // 1. 成员内部类可以直接访问外部类的静态成员，也可以直接访问外部类的实例成员 // 2. 成员内部类的实例方法中，可以直接拿到当前寄生的外部类对象：外部类名.this class People{ private int heartBeat = 100; public class Heart{ private int heartBeat = 80; public void show(){ int heartBeat = 200; System.out.println(heartBeat); // 200 System.out.println(this.heartBeat); // 80 System.out.println(People.this.heartBeat); // 100 } } } 静态内部类 # 定义：有static修饰的内部类，属于外部类自己持有。\npublic class Outer{ // 静态内部类 public static class Inner{ } } // 实例化方法：Outer.Inner oi = new Outer.Inner(); // tip:静态内部类只可以访问外部类的静态成员，不能访问外部类的实例成员。 局部内部类 # 定义：在方法中、代码块、构造器等执行体中的内部类。（没什么用）\n🥺匿名内部类（重难点） # 匿名：指程序员不需要为这个类声明名字，默认有一个隐藏的名字。\n特点：匿名内部类本质是一个子类，并会立即创建出一个子类对象。\n作用：更方便的创建一个子类对象。\n// Animal.java public abstract class Animal { public abstract void cry(); } // App.java public class App { public static void main(String[] args) { Animal eagle = new Animal() { @Override public void cry() { System.out.println(\u0026#34;飞起来\u0026#34;); } }; eagle.cry(); } } 应用场景\n调用别人提供的方法实现需求时，这个方法正好可以让我们传输一个匿名内部类对象给其使用。\n// 场景一 设置监听事件 import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class Test { public static void main(String[] args) { JFrame frame = new JFrame(\u0026#34;login\u0026#34;); frame.setSize(300, 300); frame.setLocationRelativeTo(null); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(); frame.add(panel); JButton button = new JButton(\u0026#34;登录\u0026#34;); panel.add(button); // 简化写法： // button.addActionListener(e -\u0026gt; System.out.println(\u0026#34;用户点击登录按钮\u0026#34;)); button.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.out.println(\u0026#34;用户点击登录按钮\u0026#34;); } }); // 使用 lambda表达式 简化： // button.addActionListener(e -\u0026gt; { // System.out.println(\u0026#34;用户点击登录按钮\u0026#34;); // }); // 进一步优化： // button.addActionListener(e -\u0026gt; System.out.println(\u0026#34;用户点击登录按钮\u0026#34;)) // frame.setVisible(true); } } // 场景二 使用comparator接口的匿名内部类实现对数组进行排序 import java.util.Arrays; import java.util.Comparator; public class Sort { public static void main(String[] args) { Student[] students = new Student[6]; students[0] = new Student(\u0026#34;clean\u0026#34;, 21, 170.0, \u0026#34;男\u0026#34;); students[1] = new Student(\u0026#34;小红\u0026#34;, 20, 165.0, \u0026#34;女\u0026#34;); students[2] = new Student(\u0026#34;小蓝\u0026#34;, 19, 169.0, \u0026#34;男\u0026#34;); students[3] = new Student(\u0026#34;小绿\u0026#34;, 22, 167.0, \u0026#34;女\u0026#34;); students[4] = new Student(\u0026#34;小紫\u0026#34;, 16, 155.0, \u0026#34;女\u0026#34;); students[5] = new Student(\u0026#34;小黑\u0026#34;, 15, 158.0, \u0026#34;女\u0026#34;); Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { @Override public int compare(Student o1, Student o2) { // 如果 o1 \u0026gt; o2 返回 正整数 // 如果 o1 \u0026lt; o2 返回 负整数 // 如果 o1 = o2 返回 0 return o1.getAge() - o2.getAge(); } }); // 使用lambda表达式简化 // Arrays.sort(students, (student1, student2) -\u0026gt; student1.getAge() - student2.getAge()); for (Student student : students) { System.out.println(student); } } } 函数式编程 # Lambda表达式 # Lambda表达式可以用于替代某些匿名内部类的对象，从而让程序更简洁，可读性更好。\nLambda只能简化函数时接口的匿名内部类，且接口只能有一个抽象方法。\n@FunctionalInterface interface Swim{ void swimming(); } class Test{ public static void main(String[] args){ Swim s1 = () -\u0026gt; { @Override void swimming(){ Ststem.out.println(\u0026#34;我踏🐎来啦\u0026#34;); } }; } } 具体规则：\n参数类型可以省略不写 如果只有一个参数，参数类型省略的同时\u0026quot;()\u0026ldquo;也可以省略，但多个参数不能省略\u0026rdquo;()\u0026quot; 如果Lambda表达式中只有一行代码，大括号可以不写，同时要省略分号\u0026quot;;\u0026quot;，如果这行代码是return语句，也必须去掉return 方法引用 # 静态方法引用\n类名::静态方法\n使用场景：如果某个Lambda表达式里只是调用一个静态方法，并且\u0026quot;-\u0026gt;\u0026ldquo;前后参数的形式一致，就可以使用静态方法引用。\n实例方法引用\n对象名::实例方法\n使用场景：如果某个Lambda表达式里只是通过对象名称调用一个实例方法方法，并且\u0026rdquo;-\u0026gt;\u0026ldquo;前后参数的形式一致，就可以使用实例方法引用。\n特定类型的方法引用\n特定类的名称::方法\n使用场景：如果Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数是作为该实例方法的入参的，则此时可以使用特定类型方法的引用。\nString[] names = {\u0026#34;angel\u0026#34;, \u0026#34;clean\u0026#34;, \u0026#34;gdg\u0026#34;, \u0026#34;fxg\u0026#34;, \u0026#34;yq\u0026#34;, \u0026#34;andy\u0026#34;, \u0026#34;puppy\u0026#34;, \u0026#34;doge\u0026#34;}; Arrays.sort(names, String::compareToIgnoreCase); 构造器引用\n类名::new\n使用场景：如果某个Lambda表达式里只是在创建对象，并且\u0026rdquo;-\u0026gt;\u0026ldquo;前后参数情况一致，则可以使用构造器引用。\nimport lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; public class Demo4 { public static void main(String[] args) { // CarFactory cf = new CarFactory() { // @Override // public Car getCar(String name) { // return new Car(name); // } // }; CarFactory cf = Car::new; Car c1 = cf.getCar(\u0026#34;Audi\u0026#34;); } } @FunctionalInterface interface CarFactory{ Car getCar(String name); } @Data @AllArgsConstructor @NoArgsConstructor class Car{ private String name; } ","date":"16 June 2025","externalUrl":null,"permalink":"/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/","section":"Javas","summary":"","title":"面向对象高级","type":"java"},{"content":" MarkDown 语法 # 标题 # 三级标题 # 四级标题 # 五级标题 # 六级标题 # 字体 # Hello World !\nHello World !\nHello World !\nHello World !\n引用 # 床前明月光，疑是地上霜。\n分割线 # 图片 # 超链接 # 糖心八大家\n列表 # A B C A B C 表格 # 姓名 性别 学号 clean man 21200107209 代码 # class animal{ int age; String name; void eat(){ System.out.println(\u0026#34;eat something~~~\u0026#34;); } } ","date":"5 June 2025","externalUrl":null,"permalink":"/java/first/","section":"Javas","summary":"","title":"First","type":"java"},{"content":"Hola ! Welcome to My Page ! 本科四年，归来仍是小白，因此我重生了，重生成为研究生开启学习之旅。\n","date":"6 May 2025","externalUrl":null,"permalink":"/postgraduate/","section":"","summary":"","title":"","type":"postgraduate"},{"content":"路漫漫其修远兮，吾将上下而求索。我长大的过程很艰辛，成长路上，我越来越孤独，注定了找寻自我是我人生的主线任务之一。打不倒我的，只会让我越来越强。\n大学四年，我没学到什么东西，准确说是没怎么学，随着时间的推移，大三我逐渐觉察这样下去对不起自己，对不起父母，摆在我面前的两条路，学技术和考研。悟以往之不谏，知来者之可追。高考志愿的遗憾尚在，我要考研，给自己一个再来一次的机会。\n大三上学期，10月我托老师的关系出去实习，薪水微薄，寒假我回到家开始着手考研。刚开始学习的时候效率低下，从寒假到大三下学期前的数月期间，仅仅学完了高数基础和数据结构。在大三上结束后的暑假，我回了家，两周后，我从家回来，开始泡在图书馆和宿舍学习，（暑假期间，学校的电费居然没有补贴）。这个学习节奏一直保持到考前一周。\n事实上我的战线不短，但是进度很难评。考前一周复盘，我做的事只有\n数学：一轮基础+二轮强化+10年真题（均分100，最高不到120，最低不到90）+李艳芳三套（都比较惨，没怎么及格） 英语：我不喜欢背单词，觉得枯燥乏味，所以在10月就断掉了，估计只背了3000-4000词，两遍的样子。 408：一轮基础+二轮敷衍的强化+6年真题。408这门课，广度和深度兼备了，身边没什么正经学完2轮的人，我这个进度甚至算快的。 我内心焦虑，心想分数已成定势，再学也改变不了大局。考前一天的晚上我十分亢奋，睡不着觉，凌晨三点还没一丝困意，本想起来背一会儿肖四，可担心影响考试状态还是躺下硬睡。上午考政治状态还好，记得下午考英语快困死了，考场还很热。第二天数学答题发挥很糟糕，但是成绩还算正常。408还算正常，但是分数一般。\n最终我的成绩是：68，49，101，96。我很庆幸我的选择报考院校，他很棒，也没那么难考，不会给我太大的压力，这个分数能够排在中上游，现在我已经被顺利录取。待到九月起杭。\n朝乾夕惕 盛德日新 致远至恒 务学悟真 厚德践行 在学习上，我清楚我是个没有自制力的人，希望能借助写博客，给自己一个知识产出的形式，以此激励自己持续学习。\nGood Good Study, Day Day UP ! ! !\n","date":"6 May 2025","externalUrl":null,"permalink":"/postgraduate/%E6%9D%A5%E6%97%B6%E8%B7%AF/","section":"","summary":"","title":"来时路","type":"postgraduate"},{"content":"Hola ! Welcome to My Page ! 本科四年，归来仍是小白，因此我重生了，重生成为研究生开启学习之旅。\n","date":"6 May 2025","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":"","externalUrl":null,"permalink":"/cn/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/cn/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/cn/","section":"clean的博客","summary":"","title":"clean的博客","type":"page"},{"content":"","externalUrl":null,"permalink":"/cn/languages/","section":"Languages","summary":"","title":"Languages","type":"languages"},{"content":"","externalUrl":null,"permalink":"/cn/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/cn/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]