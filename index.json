


[{"content":"","date":"16 June 2025","externalUrl":null,"permalink":"/","section":"Clean的博客","summary":"","title":"Clean的博客","type":"page"},{"content":"","date":"16 June 2025","externalUrl":null,"permalink":"/java/","section":"Javas","summary":"","title":"Javas","type":"java"},{"content":" 面向对象高级 # final关键字 # final是最终的意思，final关键字可以修饰类、方法、变量。\nfinal修饰的类称作最终类，特点是不能被继承。 final修饰的方法称为最终方法，特点是不能被重写。 final修饰的变量只能赋值一次。 使用final关键字的场景：\n修饰局部变量：方法内部和方法传入的参数均可用final修饰防止被修改。 修饰静态成员变量：称被修饰的变量为常量。 修饰实例成员变量，一般没意义。 final注意事项：\nfinal修饰基本类型变量，其内容不可改变。 final修饰引用类型变量（如数组），其地址不可改变，而数值可以改变。 常量 # 前面提到了常量，常量就是使用static final关键字修饰的成员变量，常用于记录系统的配置信息。\n使用常量的优势\n使用常量可以提高代码的可读性和可维护性。 😘类似于C的宏定义，在编译过程中，使用常量的地方全部会替换为其字面量，因此使用常量和直接使用其字面量的性能是一样的。 public class Constant{ // 常量命名规范: 全部使用大写字母 单词之间使用\u0026#34;_\u0026#34;隔开 public static final String ZJUT_SCHOOL_CODE = \u0026#34;10337\u0026#34;; public static final String ZJUT_MAIL_CODE = \u0026#34;310014\u0026#34;; public static final String WEBSITE = \u0026#34;http://www.yz.zjut.edu.cn\u0026#34; } 单例类（软件设计模式） SingleInstance Class # 作用：确保某个类只能创建出对象\n饿汉式单例 # 特点：拿对象的时候，对象早就创建好了。\n写法：\n类的构造器私有。 定义一个类变量记住类的一个对象。 定义一个类方法，返回对象。 public class A{ // 1.私有构造器 private A(){ } // 2.定义类变量记住类的一个对象 // public static final A a = new A(); private static A a = new A(); // 3.定义方法返回唯一对象 // 屏蔽除get外的操作 private static A getObject(){ return a; } } 懒汉式单例 # 特点：拿对象时才开始创建对象\n写法：\n私有构造器 定义类变量存储对象 定义方法返回唯一对象 public class B{ // 1.私有构造器 private B(){ } // 2.定义类变量存储对象 private static B b; // 3.定义方法返回唯一对象 private static B getObject(){ if (b == null){ b = new B(); } return b; } } 枚举类 # 认识枚举类\n枚举类的写法：\n// 修饰符 enum 枚举类名{ // 名称1, 名称2,...; // 其他成员... // } // A.java public enum A{ X, Y, Z; ... } 将A.java编译后进行反编译\n(base) clean@fxg Downloads % touch A.java (base) clean@fxg Downloads % vim A.java (base) clean@fxg Downloads % javac A.java (base) clean@fxg Downloads % javap A.class 得到代码如下：\npublic final class A extends java.lang.Enum\u0026lt;A\u0026gt; { public static final A X; public static final A Y; public static final A Z; public static A[] values(); public static A valueOf(java.lang.String); static {}; } 观察到枚举类的一些特点：\n枚举类被final修饰，即枚举类是最终类，不能被继承。 枚举类都继承了java.lang.Enum类 😳枚举类中第一行只能罗列一些名称（如上面A.java例子中的XYZ），这些名称都是常量，并且每个常量会记住枚举类的一个对象。 枚举类的构造器是私有的，因此枚举类不能对外创建对象。 此外，编译器为枚举类新增了几个方法：\npublic static void main(String[] args){ A a1 = A.X; System.out.println(a1); // out: X System.out.println(a1.name()); // out: X System.out.println(a1.ordinal()); // 0 (索引) } 枚举类的常见应用场景\n枚举类适合做信息分类和标志\n抽象类 # abstract 关键字 可以修饰类和方法，被修饰的分别称为抽象类和抽象方法，抽象方法不允许有方法体。\n抽象类的特点：\n抽象类中不一定有抽象方法，有抽象方法必须是抽象类。 类有的成员：成员变量、方法、构造器、抽象类都可以有。 😊抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现。 一个类继承抽象类，必须重写完继承的全部抽象方法，否则这个类也必须定义成抽象类。 抽象类的好处：更好支持多态。\n😜模版方法软件设计模式\n提供一个方法作为完成某类功能的模版，模版方法封装了每个实现步骤，但允许子类提供特定步骤的实现。\n模版方法设计模式可以提高代码复用、简化子类设计。\ntips：\n模版方法使用final修饰，防止被重写。 一旦子类重写模版方法，模版方法失效。 接口（Interface） # //JDK 8以前 接口中只能定义常量和抽象方法： public interface A{ // 接口中定义常量可以省略 public static final String SCHOOL_NAME = \u0026#34;浙江工业大学\u0026#34;; // 接口中定义抽象方法可以省略 public abstract void run(); } // JDK 8开始，接口新增了三种形式的方法： public interface B{ // 1. 默认方法(普通实例方法)，必须用default修饰 // 默认使用public修饰 // 调用方法: 使用接口的实现类的对象调用 default void go { System.out.println(\u0026#34;function go running~~~\u0026#34;); run(); } // 2. 私有方法 // 私有的实例方法 // 调用方法: 使用接口中的其他实例方法调用 private void run { System.out.println(\u0026#34;function run is running~~~\u0026#34;); } // 3. 静态方法(类方法) 使用static修饰 // 默认使用 public 修饰 // 调用方法: 静态方法只能用接口名调用 static void fly { System.out.println(\u0026#34;function fly is running~~~\u0026#34;); } } 😴实现类实现多个结构，必须重写全部接口的全部抽象方法，否则这个类必须定义为抽象类。\n接口的好处\n弥补了类单继承的不足，一个类可以实现多个接口，使类角色更多，功能更强 让程序可以面向接口编程，这样程序员可以灵活方便的切换各种业务实现（更利于程序的解耦合） 接口注意事项：\n接口与接口可以多继承，一个接口可以继承多个接口 多个接口存在方法签名冲突时，不支持多继承和多实现 一个类继承父类的同时实现了接口，如果父类中和接口中有同名的方法，实现类会优先用父类的 一个类实现了多个接口，如果存在同名的默认方法，可以不冲突，这个类重写该方法即可 抽象类、接口的对比 # 相同点：\n都是抽象形式，都可以有抽象方法，都不能创建对象 都是派生子类形式：抽象类时被子类继承使用，接口是被实现类实现 一个类继承抽象类，或者实现接口，都必须重写完他们的抽象方法，否则该类必须为抽象类 都能支持多态，实现解耦合 不同点：\n抽象类中可以定义类的全部普通成员，接口是能定义常量、抽象方法（JDK 8 前） 抽象类只能被单继承，接口能被类多实现 一个类继承抽象类就不能再继承其他类，一个类实现了接口还可以继承其他类或实现其他接口 抽象类体现模版思想，更利于做父类，实现代码的复用性 最佳实践 接口适合做功能的解耦合，解耦合性更强更灵活 最佳实践 代码块 # // 代码块分为下面两种: // 1. 静态代码块 // 格式: static{} // 特点: 类加载时自动执行 由于类只加载一次 所以静态代码块也只会执行一次 // 作用: 完成类的初始化 如对静态变量的初始化赋值 // 2. 实例代码块 // 格式: {} // 特点: 每次创建对象时 执行实例代码块 并在构造器前执行 // 作用: 和构造器一样都是用来完成对象初始化的 如对实例变量进行初始化 public class CodeDemo{ { System.out.println(\u0026#34;====实例代码块====\u0026#34;); } static { System.out.println(\u0026#34;====静态代码块====\u0026#34;); } public static void main(String[] args){ System.out.println(\u0026#34;====main 方法====\u0026#34;); } } 内部类（掌握语法） # 定义：如果一个类定义在另一个类的内部，这个类就是内部类。\n成员内部类 # // 定义 public class Outer { // 没有 static 说明内部类属于对象 public class Inner { public void show(){ System.out.println(\u0026#34;show\u0026#34;); } }\t} // 实例化并调用 public class Main{ public static void main(String[] args){ Outer.Inner oi = new Outer().new Inner(); oi.show(); } } // 成员内部类访问外部类成员的特点（拓展） // 1. 成员内部类可以直接访问外部类的静态成员，也可以直接访问外部类的实例成员 // 2. 成员内部类的实例方法中，可以直接拿到当前寄生的外部类对象：外部类名.this class People{ private int heartBeat = 100; public class Heart{ private int heartBeat = 80; public void show(){ int heartBeat = 200; System.out.println(heartBeat); // 200 System.out.println(this.heartBeat); // 80 System.out.println(People.this.heartBeat); // 100 } } } 静态内部类 # 定义：有static修饰的内部类，属于外部类自己持有。\npublic class Outer{ // 静态内部类 public static class Inner{ } } // 实例化方法：Outer.Inner oi = new Outer.Inner(); // tip:静态内部类只可以访问外部类的静态成员，不能访问外部类的实例成员。 局部内部类 # 定义：在方法中、代码块、构造器等执行体中的内部类。（没什么用）\n🥺匿名内部类（重难点） # 匿名：指程序员不需要为这个类声明名字，默认有一个隐藏的名字。\n特点：匿名内部类本质是一个子类，并会立即创建出一个子类对象。\n作用：更方便的创建一个子类对象。\n// Animal.java public abstract class Animal { public abstract void cry(); } // App.java public class App { public static void main(String[] args) { Animal eagle = new Animal() { @Override public void cry() { System.out.println(\u0026#34;飞起来\u0026#34;); } }; eagle.cry(); } } 应用场景\n调用别人提供的方法实现需求时，这个方法正好可以让我们传输一个匿名内部类对象给其使用。\n// 场景一 设置监听事件 import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class Test { public static void main(String[] args) { JFrame frame = new JFrame(\u0026#34;login\u0026#34;); frame.setSize(300, 300); frame.setLocationRelativeTo(null); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(); frame.add(panel); JButton button = new JButton(\u0026#34;登录\u0026#34;); panel.add(button); // 简化写法： // button.addActionListener(e -\u0026gt; System.out.println(\u0026#34;用户点击登录按钮\u0026#34;)); button.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.out.println(\u0026#34;用户点击登录按钮\u0026#34;); } }); // 使用 lambda表达式 简化： // button.addActionListener(e -\u0026gt; { // System.out.println(\u0026#34;用户点击登录按钮\u0026#34;); // }); // 进一步优化： // button.addActionListener(e -\u0026gt; System.out.println(\u0026#34;用户点击登录按钮\u0026#34;)) // frame.setVisible(true); } } // 场景二 使用comparator接口的匿名内部类实现对数组进行排序 import java.util.Arrays; import java.util.Comparator; public class Sort { public static void main(String[] args) { Student[] students = new Student[6]; students[0] = new Student(\u0026#34;clean\u0026#34;, 21, 170.0, \u0026#34;男\u0026#34;); students[1] = new Student(\u0026#34;小红\u0026#34;, 20, 165.0, \u0026#34;女\u0026#34;); students[2] = new Student(\u0026#34;小蓝\u0026#34;, 19, 169.0, \u0026#34;男\u0026#34;); students[3] = new Student(\u0026#34;小绿\u0026#34;, 22, 167.0, \u0026#34;女\u0026#34;); students[4] = new Student(\u0026#34;小紫\u0026#34;, 16, 155.0, \u0026#34;女\u0026#34;); students[5] = new Student(\u0026#34;小黑\u0026#34;, 15, 158.0, \u0026#34;女\u0026#34;); Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { @Override public int compare(Student o1, Student o2) { // 如果 o1 \u0026gt; o2 返回 正整数 // 如果 o1 \u0026lt; o2 返回 负整数 // 如果 o1 = o2 返回 0 return o1.getAge() - o2.getAge(); } }); // 使用lambda表达式简化 // Arrays.sort(students, (student1, student2) -\u0026gt; student1.getAge() - student2.getAge()); for (Student student : students) { System.out.println(student); } } } 函数式编程 # Lambda表达式 # Lambda表达式可以用于替代某些匿名内部类的对象，从而让程序更简洁，可读性更好。\nLambda只能简化函数时接口的匿名内部类，且接口只能有一个抽象方法。\n@FunctionalInterface interface Swim{ void swimming(); } class Test{ public static void main(String[] args){ Swim s1 = () -\u0026gt; { @Override void swimming(){ Ststem.out.println(\u0026#34;我踏🐎来啦\u0026#34;); } }; } } 具体规则：\n参数类型可以省略不写 如果只有一个参数，参数类型省略的同时\u0026quot;()\u0026ldquo;也可以省略，但多个参数不能省略\u0026rdquo;()\u0026quot; 如果Lambda表达式中只有一行代码，大括号可以不写，同时要省略分号\u0026quot;;\u0026quot;，如果这行代码是return语句，也必须去掉return 方法引用 # 静态方法引用\n类名::静态方法\n使用场景：如果某个Lambda表达式里只是调用一个静态方法，并且\u0026quot;-\u0026gt;\u0026ldquo;前后参数的形式一致，就可以使用静态方法引用。\n实例方法引用\n对象名::实例方法\n使用场景：如果某个Lambda表达式里只是通过对象名称调用一个实例方法方法，并且\u0026rdquo;-\u0026gt;\u0026ldquo;前后参数的形式一致，就可以使用实例方法引用。\n特定类型的方法引用\n特定类的名称::方法\n使用场景：如果Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数是作为该实例方法的入参的，则此时可以使用特定类型方法的引用。\nString[] names = {\u0026#34;angel\u0026#34;, \u0026#34;clean\u0026#34;, \u0026#34;gdg\u0026#34;, \u0026#34;fxg\u0026#34;, \u0026#34;yq\u0026#34;, \u0026#34;andy\u0026#34;, \u0026#34;puppy\u0026#34;, \u0026#34;doge\u0026#34;}; Arrays.sort(names, String::compareToIgnoreCase); 构造器引用\n类名::new\n使用场景：如果某个Lambda表达式里只是在创建对象，并且\u0026rdquo;-\u0026gt;\u0026ldquo;前后参数情况一致，则可以使用构造器引用。\nimport lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; public class Demo4 { public static void main(String[] args) { // CarFactory cf = new CarFactory() { // @Override // public Car getCar(String name) { // return new Car(name); // } // }; CarFactory cf = Car::new; Car c1 = cf.getCar(\u0026#34;Audi\u0026#34;); } } @FunctionalInterface interface CarFactory{ Car getCar(String name); } @Data @AllArgsConstructor @NoArgsConstructor class Car{ private String name; } ","date":"16 June 2025","externalUrl":null,"permalink":"/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/","section":"Javas","summary":"","title":"面向对象高级","type":"java"},{"content":" MarkDown 语法 # 标题 # 三级标题 # 四级标题 # 五级标题 # 六级标题 # 字体 # Hello World !\nHello World !\nHello World !\nHello World !\n引用 # 床前明月光，疑是地上霜。\n分割线 # 图片 # 超链接 # 糖心八大家\n列表 # A B C A B C 表格 # 姓名 性别 学号 clean man 21200107209 代码 # class animal{ int age; String name; void eat(){ System.out.println(\u0026#34;eat something~~~\u0026#34;); } } ","date":"5 June 2025","externalUrl":null,"permalink":"/java/first/","section":"Javas","summary":"","title":"First","type":"java"},{"content":"Hola ! Welcome to My Page ! 本科四年，归来仍是小白，因此我重生了，重生成为研究生开启学习之旅。\n","date":"6 May 2025","externalUrl":null,"permalink":"/postgraduate/","section":"","summary":"","title":"","type":"postgraduate"},{"content":"路漫漫其修远兮，吾将上下而求索。我长大的过程很艰辛，成长路上，我越来越孤独，注定了找寻自我是我人生的主线任务之一。打不倒我的，只会让我越来越强。\n大学四年，我没学到什么东西，准确说是没怎么学，随着时间的推移，大三我逐渐觉察这样下去对不起自己，对不起父母，摆在我面前的两条路，学技术和考研。悟以往之不谏，知来者之可追。高考志愿的遗憾尚在，我要考研，给自己一个再来一次的机会。\n大三上学期，10月我托老师的关系出去实习，薪水微薄，寒假我回到家开始着手考研。刚开始学习的时候效率低下，从寒假到大三下学期前的数月期间，仅仅学完了高数基础和数据结构。在大三上结束后的暑假，我回了家，两周后，我从家回来，开始泡在图书馆和宿舍学习，（暑假期间，学校的电费居然没有补贴）。这个学习节奏一直保持到考前一周。\n事实上我的战线不短，但是进度很难评。考前一周复盘，我做的事只有\n数学：一轮基础+二轮强化+10年真题（均分100，最高不到120，最低不到90）+李艳芳三套（都比较惨，没怎么及格） 英语：我不喜欢背单词，觉得枯燥乏味，所以在10月就断掉了，估计只背了3000-4000词，两遍的样子。 408：一轮基础+二轮敷衍的强化+6年真题。408这门课，广度和深度兼备了，身边没什么正经学完2轮的人，我这个进度甚至算快的。 我内心焦虑，心想分数已成定势，再学也改变不了大局。考前一天的晚上我十分亢奋，睡不着觉，凌晨三点还没一丝困意，本想起来背一会儿肖四，可担心影响考试状态还是躺下硬睡。上午考政治状态还好，记得下午考英语快困死了，考场还很热。第二天数学答题发挥很糟糕，但是成绩还算正常。408还算正常，但是分数一般。\n最终我的成绩是：68，49，101，96。我很庆幸我的选择报考院校，他很棒，也没那么难考，不会给我太大的压力，这个分数能够排在中上游，现在我已经被顺利录取。待到九月起杭。\n朝乾夕惕 盛德日新 致远至恒 务学悟真 厚德践行 在学习上，我清楚我是个没有自制力的人，希望能借助写博客，给自己一个知识产出的形式，以此激励自己持续学习。\nGood Good Study, Day Day UP ! ! !\n","date":"6 May 2025","externalUrl":null,"permalink":"/postgraduate/%E6%9D%A5%E6%97%B6%E8%B7%AF/","section":"","summary":"","title":"来时路","type":"postgraduate"},{"content":"Hola ! Welcome to My Page ! 本科四年，归来仍是小白，因此我重生了，重生成为研究生开启学习之旅。\n","date":"6 May 2025","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":" 简介 # 这是 粗体 文本，这是 斜体 文本。 访问 Hugo 网站！\n","date":"6 May 2025","externalUrl":null,"permalink":"/posts/my-first-post/","section":"","summary":"","title":"我的第一篇博客文章","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/languages/","section":"Languages","summary":"","title":"Languages","type":"languages"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]